"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModuleFederationConfig = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
function getModuleFederationConfig(mfConfig, determineRemoteUrl, options = { isServer: false }) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let projectGraph;
        try {
            projectGraph = (0, devkit_1.readCachedProjectGraph)();
        }
        catch (e) {
            projectGraph = yield (0, devkit_1.createProjectGraphAsync)();
        }
        const project = (_a = projectGraph.nodes[mfConfig.name]) === null || _a === void 0 ? void 0 : _a.data;
        if (!project) {
            throw Error(`Cannot find project "${mfConfig.name}". Check that the name is correct in module-federation.config.js`);
        }
        const dependencies = (0, devkit_1.getDependentPackagesForProject)(projectGraph, mfConfig.name);
        const sharedLibraries = (0, devkit_1.shareWorkspaceLibraries)(dependencies.workspaceLibraries);
        const npmPackages = (0, devkit_1.sharePackages)(dependencies.npmPackages);
        const sharedDependencies = Object.assign(Object.assign({}, sharedLibraries.getLibraries()), npmPackages);
        (0, devkit_1.applySharedFunction)(sharedDependencies, mfConfig.shared);
        (0, devkit_1.applyAdditionalShared)(sharedDependencies, mfConfig.additionalShared, projectGraph);
        const mapRemotesFunction = options.isServer ? devkit_1.mapRemotesForSSR : devkit_1.mapRemotes;
        const mappedRemotes = !mfConfig.remotes || mfConfig.remotes.length === 0
            ? {}
            : mapRemotesFunction(mfConfig.remotes, 'js', determineRemoteUrl);
        return { sharedLibraries, sharedDependencies, mappedRemotes };
    });
}
exports.getModuleFederationConfig = getModuleFederationConfig;
//# sourceMappingURL=utils.js.map