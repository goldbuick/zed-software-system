"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withModuleFederation = void 0;
const tslib_1 = require("tslib");
const project_graph_1 = require("nx/src/project-graph/project-graph");
const utils_1 = require("./utils");
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");
function determineRemoteUrl(remote) {
    var _a, _b, _c, _d, _e;
    const remoteConfiguration = (0, project_graph_1.readCachedProjectConfiguration)(remote);
    const serveTarget = (_a = remoteConfiguration === null || remoteConfiguration === void 0 ? void 0 : remoteConfiguration.targets) === null || _a === void 0 ? void 0 : _a.serve;
    if (!serveTarget) {
        throw new Error(`Cannot automatically determine URL of remote (${remote}). Looked for property "host" in the project's "serve" target.\n
      You can also use the tuple syntax in your webpack config to configure your remotes. e.g. \`remotes: [['remote1', 'http://localhost:4201']]\``);
    }
    const host = (_c = (_b = serveTarget.options) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'http://localhost';
    const port = (_e = (_d = serveTarget.options) === null || _d === void 0 ? void 0 : _d.port) !== null && _e !== void 0 ? _e : 4201;
    return `${host.endsWith('/') ? host.slice(0, -1) : host}:${port}/remoteEntry.js`;
}
/**
 * @param {ModuleFederationConfig} options
 * @return {Promise<AsyncNxWebpackPlugin>}
 */
function withModuleFederation(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const reactWebpackConfig = require('../../plugins/webpack');
        const { sharedDependencies, sharedLibraries, mappedRemotes } = yield (0, utils_1.getModuleFederationConfig)(options, determineRemoteUrl);
        return (config, ctx) => {
            var _a;
            config = reactWebpackConfig(config, ctx);
            config.output.uniqueName = options.name;
            config.output.publicPath = 'auto';
            config.optimization = {
                runtimeChunk: false,
            };
            config.experiments = Object.assign(Object.assign({}, config.experiments), { outputModule: true });
            config.plugins.push(new ModuleFederationPlugin({
                name: options.name,
                library: (_a = options.library) !== null && _a !== void 0 ? _a : { type: 'module' },
                filename: 'remoteEntry.js',
                exposes: options.exposes,
                remotes: mappedRemotes,
                shared: Object.assign({}, sharedDependencies),
            }), sharedLibraries.getReplacementPlugin());
            return config;
        };
    });
}
exports.withModuleFederation = withModuleFederation;
//# sourceMappingURL=with-module-federation.js.map