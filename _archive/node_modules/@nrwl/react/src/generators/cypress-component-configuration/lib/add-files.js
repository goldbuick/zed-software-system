"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addFiles = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const versions_1 = require("nx/src/utils/versions");
const ast_utils_1 = require("../../../utils/ast-utils");
const component_test_1 = require("../../component-test/component-test");
const ensure_typescript_1 = require("@nrwl/js/src/utils/typescript/ensure-typescript");
let tsModule;
const allowedFileExt = new RegExp(/\.[jt]sx?/g);
const isSpecFile = new RegExp(/(spec|test)\./g);
function addFiles(tree, projectConfig, options, found) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const cypressConfigPath = (0, devkit_1.joinPathFragments)(projectConfig.root, 'cypress.config.ts');
        if (tree.exists(cypressConfigPath)) {
            tree.delete(cypressConfigPath);
        }
        const actualBundler = yield getBundler(found, tree);
        if (options.bundler && options.bundler !== actualBundler) {
            devkit_1.logger.warn(`You have specified ${options.bundler} as the bundler but this project is configured to use ${actualBundler}.
      This may cause errors. If you are seeing errors, try removing the --bundler option.`);
        }
        (0, devkit_1.generateFiles)(tree, (0, devkit_1.joinPathFragments)(__dirname, '..', 'files'), projectConfig.root, {
            tpl: '',
            bundler: (_a = options.bundler) !== null && _a !== void 0 ? _a : actualBundler,
        });
        if (options.bundler === 'webpack' ||
            (!options.bundler && actualBundler === 'webpack')) {
            (0, devkit_1.addDependenciesToPackageJson)(tree, {}, { '@nrwl/webpack': versions_1.nxVersion });
        }
        if (options.generateTests) {
            const filePaths = [];
            (0, devkit_1.visitNotIgnoredFiles)(tree, projectConfig.sourceRoot, (filePath) => {
                if (isComponent(tree, filePath)) {
                    filePaths.push(filePath);
                }
            });
            for (const filePath of filePaths) {
                yield (0, component_test_1.componentTestGenerator)(tree, {
                    project: options.project,
                    componentPath: filePath,
                });
            }
        }
    });
}
exports.addFiles = addFiles;
function getBundler(found, tree) {
    var _a, _b, _c;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (found.target && ((_a = found.config) === null || _a === void 0 ? void 0 : _a.executor)) {
            return found.config.executor === '@nrwl/vite:build' ? 'vite' : 'webpack';
        }
        const { target, project } = (0, devkit_1.parseTargetString)(found.target, yield (0, devkit_1.createProjectGraphAsync)());
        const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, project);
        return ((_c = (_b = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.targets) === null || _b === void 0 ? void 0 : _b[target]) === null || _c === void 0 ? void 0 : _c.executor) === '@nrwl/vite:build'
            ? 'vite'
            : 'webpack';
    });
}
function isComponent(tree, filePath) {
    if (!tsModule) {
        tsModule = (0, ensure_typescript_1.ensureTypescript)();
    }
    if (isSpecFile.test(filePath) || !allowedFileExt.test(filePath)) {
        return false;
    }
    const content = tree.read(filePath, 'utf-8');
    const sourceFile = tsModule.createSourceFile(filePath, content, tsModule.ScriptTarget.Latest, true);
    const cmpDeclaration = (0, ast_utils_1.getComponentNode)(sourceFile);
    return !!cmpDeclaration;
}
//# sourceMappingURL=add-files.js.map