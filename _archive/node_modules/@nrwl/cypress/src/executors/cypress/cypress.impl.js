"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
require("dotenv/config");
const fs_1 = require("fs");
const path_1 = require("path");
const ct_helpers_1 = require("../../utils/ct-helpers");
const cypress_version_1 = require("../../utils/cypress-version");
const Cypress = require('cypress'); // @NOTE: Importing via ES6 messes the whole test dependencies.
function cypressExecutor(options, context) {
    var _a, e_1, _b, _c;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        options = normalizeOptions(options, context);
        // this is used by cypress component testing presets to build the executor contexts with the correct configuration options.
        process.env.NX_CYPRESS_TARGET_CONFIGURATION = context.configurationName;
        let success;
        try {
            for (var _d = true, _e = tslib_1.__asyncValues(startDevServer(options, context)), _f; _f = yield _e.next(), _a = _f.done, !_a;) {
                _c = _f.value;
                _d = false;
                try {
                    const baseUrl = _c;
                    try {
                        success = yield runCypress(baseUrl, options);
                        if (!options.watch)
                            break;
                    }
                    catch (e) {
                        devkit_1.logger.error(e.message);
                        success = false;
                        if (!options.watch)
                            break;
                    }
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return { success };
    });
}
exports.default = cypressExecutor;
function normalizeOptions(options, context) {
    var _a, _b, _c;
    options.env = options.env || {};
    if (options.tsConfig) {
        const tsConfigPath = (0, path_1.join)(context.root, options.tsConfig);
        options.env.tsConfig = tsConfigPath;
        process.env.TS_NODE_PROJECT = tsConfigPath;
    }
    if (options.testingType === 'component') {
        const project = (_b = (_a = context === null || context === void 0 ? void 0 : context.projectGraph) === null || _a === void 0 ? void 0 : _a.nodes) === null || _b === void 0 ? void 0 : _b[context.projectName];
        if ((_c = project === null || project === void 0 ? void 0 : project.data) === null || _c === void 0 ? void 0 : _c.root) {
            options.ctTailwindPath = (0, ct_helpers_1.getTempTailwindPath)(context);
        }
    }
    checkSupportedBrowser(options);
    warnDeprecatedHeadless(options);
    warnDeprecatedCypressVersion();
    return options;
}
function checkSupportedBrowser({ browser }) {
    // Browser was not passed in as an option, cypress will use whatever default it has set and we dont need to check it
    if (!browser) {
        return;
    }
    if ((0, cypress_version_1.installedCypressVersion)() >= 4 && browser == 'canary') {
        devkit_1.logger.warn((0, devkit_1.stripIndents) `
  Warning:
  You are using a browser that is not supported by cypress v4+.

  Read here for more info:
  https://docs.cypress.io/guides/references/migration-guide.html#Launching-Chrome-Canary-with-browser
  `);
        return;
    }
    const supportedV3Browsers = ['electron', 'chrome', 'canary', 'chromium'];
    if ((0, cypress_version_1.installedCypressVersion)() <= 3 &&
        !supportedV3Browsers.includes(browser)) {
        devkit_1.logger.warn((0, devkit_1.stripIndents) `
    Warning:
    You are using a browser that is not supported by cypress v3.
    `);
        return;
    }
}
function warnDeprecatedHeadless({ headless }) {
    if ((0, cypress_version_1.installedCypressVersion)() < 8 || headless === undefined) {
        return;
    }
    if (headless) {
        const deprecatedMsg = (0, devkit_1.stripIndents) `
    NOTE:
    You can now remove the use of the '--headless' flag during 'cypress run' as this is the default for all browsers.`;
        devkit_1.logger.warn(deprecatedMsg);
    }
}
function warnDeprecatedCypressVersion() {
    if ((0, cypress_version_1.installedCypressVersion)() < 10) {
        devkit_1.logger.warn((0, devkit_1.stripIndents) `
NOTE:
Support for Cypress versions < 10 is deprecated. Please upgrade to at least Cypress version 10. 
A generator to migrate from v8 to v10 is provided. See https://nx.dev/cypress/v10-migration-guide
`);
    }
}
function startDevServer(opts, context) {
    var _a, _b, _c;
    return tslib_1.__asyncGenerator(this, arguments, function* startDevServer_1() {
        var _d, e_2, _e, _f;
        // no dev server, return the provisioned base url
        if (!opts.devServerTarget || opts.skipServe) {
            yield yield tslib_1.__await(opts.baseUrl);
            return yield tslib_1.__await(void 0);
        }
        const { project, target, configuration } = (0, devkit_1.parseTargetString)(opts.devServerTarget);
        const devServerTargetOpts = (0, devkit_1.readTargetOptions)({ project, target, configuration }, context);
        const targetSupportsWatchOpt = Object.keys(devServerTargetOpts).includes('watch');
        try {
            for (var _g = true, _h = tslib_1.__asyncValues(yield tslib_1.__await((0, devkit_1.runExecutor)({ project, target, configuration }, 
            // @NOTE: Do not forward watch option if not supported by the target dev server,
            // this is relevant for running Cypress against dev server target that does not support this option,
            // for instance @nguniversal/builders:ssr-dev-server.
            targetSupportsWatchOpt ? { watch: opts.watch } : {}, context))), _j; _j = yield tslib_1.__await(_h.next()), _d = _j.done, !_d;) {
                _f = _j.value;
                _g = false;
                try {
                    const output = _f;
                    if (!output.success && !opts.watch)
                        throw new Error('Could not compile application files');
                    if (!opts.baseUrl &&
                        !output.baseUrl &&
                        !((_a = output.info) === null || _a === void 0 ? void 0 : _a.baseUrl) &&
                        ((_b = output.info) === null || _b === void 0 ? void 0 : _b.port)) {
                        output.baseUrl = `http://localhost:${output.info.port}`;
                    }
                    yield yield tslib_1.__await(opts.baseUrl || output.baseUrl || ((_c = output.info) === null || _c === void 0 ? void 0 : _c.baseUrl));
                }
                finally {
                    _g = true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (!_g && !_d && (_e = _h.return)) yield tslib_1.__await(_e.call(_h));
            }
            finally { if (e_2) throw e_2.error; }
        }
    });
}
/**
 * @whatItDoes Initialize the Cypress test runner with the provided project configuration.
 * By default, Cypress will run tests from the CLI without the GUI and provide directly the results in the console output.
 * If `watch` is `true`: Open Cypress in the interactive GUI to interact directly with the application.
 */
function runCypress(baseUrl, opts) {
    var _a, _b;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const cypressVersion = (0, cypress_version_1.installedCypressVersion)();
        // Cypress expects the folder where a cypress config is present
        const projectFolderPath = (0, path_1.dirname)(opts.cypressConfig);
        const options = {
            project: projectFolderPath,
            configFile: (0, path_1.basename)(opts.cypressConfig),
        };
        // If not, will use the `baseUrl` normally from `cypress.json`
        if (baseUrl) {
            options.config = { baseUrl };
        }
        if (opts.browser) {
            options.browser = opts.browser;
        }
        if (opts.env) {
            options.env = opts.env;
        }
        if (opts.spec) {
            options.spec = opts.spec;
        }
        options.tag = opts.tag;
        options.exit = opts.exit;
        options.headed = opts.headed;
        if (opts.headless) {
            options.headless = opts.headless;
        }
        options.record = opts.record;
        options.key = opts.key;
        options.parallel = opts.parallel;
        options.ciBuildId = (_a = opts.ciBuildId) === null || _a === void 0 ? void 0 : _a.toString();
        options.group = opts.group;
        // renamed in cy 10
        if (cypressVersion >= 10) {
            (_b = options.config) !== null && _b !== void 0 ? _b : (options.config = {});
            options.config[opts.testingType] = {
                excludeSpecPattern: opts.ignoreTestFiles,
            };
        }
        else {
            options.ignoreTestFiles = opts.ignoreTestFiles;
        }
        if (opts.reporter) {
            options.reporter = opts.reporter;
        }
        if (opts.reporterOptions) {
            options.reporterOptions = opts.reporterOptions;
        }
        options.testingType = opts.testingType;
        const result = yield (opts.watch
            ? Cypress.open(options)
            : Cypress.run(options));
        if (opts.ctTailwindPath && (0, fs_1.existsSync)(opts.ctTailwindPath)) {
            (0, fs_1.unlinkSync)(opts.ctTailwindPath);
        }
        /**
         * `cypress.open` is returning `0` and is not of the same type as `cypress.run`.
         * `cypress.open` is the graphical UI, so it will be obvious to know what wasn't
         * working. Forcing the build to success when `cypress.open` is used.
         */
        return !result.totalFailed && !result.failures;
    });
}
//# sourceMappingURL=cypress.impl.js.map