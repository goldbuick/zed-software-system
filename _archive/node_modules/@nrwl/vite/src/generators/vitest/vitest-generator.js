"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    vitestGenerator: ()=>vitestGenerator,
    default: ()=>_default,
    vitestSchematic: ()=>vitestSchematic
});
const _extends = require("@swc/helpers/lib/_extends.js").default;
const _devkit = require("@nrwl/devkit");
const _generatorUtils = require("../../utils/generator-utils");
const _runTasksInSerial = require("@nrwl/workspace/src/utilities/run-tasks-in-serial");
const _init = require("../init/init");
const _versions = require("../../utils/versions");
var _json, _compilerOptions, _compilerOptions1;
async function vitestGenerator(tree, schema) {
    const tasks = [];
    const { targets , root , projectType  } = (0, _devkit.readProjectConfiguration)(tree, schema.project);
    var _testTarget, ref;
    let testTarget = (ref = (_testTarget = schema.testTarget) != null ? _testTarget : (0, _generatorUtils.findExistingTargetsInProject)(targets).validFoundTargetName.test) != null ? ref : 'test';
    (0, _generatorUtils.addOrChangeTestTarget)(tree, schema, testTarget);
    const initTask = (0, _init.default)(tree, {
        uiFramework: schema.uiFramework
    });
    tasks.push(initTask);
    if (!schema.skipViteConfig) {
        (0, _generatorUtils.createOrEditViteConfig)(tree, _extends({}, schema, {
            includeVitest: true,
            includeLib: projectType === 'library'
        }), true);
    }
    createFiles(tree, schema, root);
    updateTsConfig(tree, schema, root);
    const installCoverageProviderTask = (0, _devkit.addDependenciesToPackageJson)(tree, {}, schema.coverageProvider === 'istanbul' ? {
        '@vitest/coverage-istanbul': _versions.vitestCoverageIstanbulVersion
    } : {
        '@vitest/coverage-c8': _versions.vitestCoverageC8Version
    });
    tasks.push(installCoverageProviderTask);
    await (0, _devkit.formatFiles)(tree);
    return (0, _runTasksInSerial.runTasksInSerial)(...tasks);
}
function updateTsConfig(tree, options, projectRoot) {
    (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.json'), (json)=>{
        var ref, ref1;
        if (json.references && !json.references.some((r)=>r.path === './tsconfig.spec.json')) {
            json.references.push({
                path: './tsconfig.spec.json'
            });
        }
        if (!((ref = json.compilerOptions) == null ? void 0 : (ref1 = ref.types) == null ? void 0 : ref1.includes('vitest'))) {
            var ref2;
            if ((ref2 = json.compilerOptions) == null ? void 0 : ref2.types) {
                json.compilerOptions.types.push('vitest');
            } else {
                var _compilerOptions;
                (_compilerOptions = (_json = json).compilerOptions) != null ? _compilerOptions : _json.compilerOptions = {};
                json.compilerOptions.types = [
                    'vitest'
                ];
            }
        }
        return json;
    });
    if (options.inSourceTests) {
        const tsconfigLibPath = (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.lib.json');
        const tsconfigAppPath = (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.app.json');
        if (tree.exists(tsconfigLibPath)) {
            (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.lib.json'), (json)=>{
                var _types;
                ((_types = (_compilerOptions = json.compilerOptions).types) != null ? _types : _compilerOptions.types = []).push('vitest/importMeta');
                return json;
            });
        } else if (tree.exists(tsconfigAppPath)) {
            (0, _devkit.updateJson)(tree, (0, _devkit.joinPathFragments)(projectRoot, 'tsconfig.app.json'), (json)=>{
                var _types;
                ((_types = (_compilerOptions1 = json.compilerOptions).types) != null ? _types : _compilerOptions1.types = []).push('vitest/importMeta');
                return json;
            });
        }
    }
}
function createFiles(tree, options, projectRoot) {
    (0, _devkit.generateFiles)(tree, (0, _devkit.joinPathFragments)(__dirname, 'files'), projectRoot, _extends({
        tmpl: ''
    }, options, {
        projectRoot,
        offsetFromRoot: (0, _devkit.offsetFromRoot)(projectRoot)
    }));
}
const _default = vitestGenerator;
const vitestSchematic = (0, _devkit.convertNxGenerator)(vitestGenerator);

//# sourceMappingURL=vitest-generator.js.map