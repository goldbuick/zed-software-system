"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    viteConfigurationGenerator: ()=>viteConfigurationGenerator,
    default: ()=>_default,
    configurationSchematic: ()=>configurationSchematic
});
const _devkit = require("@nrwl/devkit");
const _runTasksInSerial = require("@nrwl/workspace/src/utilities/run-tasks-in-serial");
const _generatorUtils = require("../../utils/generator-utils");
const _init = require("../init/init");
const _vitestGenerator = require("../vitest/vitest-generator");
var _schema;
async function viteConfigurationGenerator(tree, schema) {
    const tasks = [];
    const { targets , projectType , root  } = (0, _devkit.readProjectConfiguration)(tree, schema.project);
    let buildTargetName = 'build';
    let serveTargetName = 'serve';
    let testTargetName = 'test';
    var _includeLib;
    (_includeLib = (_schema = schema).includeLib) != null ? _includeLib : _schema.includeLib = projectType === 'library';
    /**
   * This is for when we are converting an existing project
   * to use the vite executors.
   */ let projectAlreadyHasViteTargets = {};
    if (!schema.newProject) {
        var ref, ref1;
        const userProvidedTargetName = {
            build: schema.buildTarget,
            serve: schema.serveTarget,
            test: schema.testTarget
        };
        const { validFoundTargetName , projectContainsUnsupportedExecutor , userProvidedTargetIsUnsupported , alreadyHasNxViteTargets  } = (0, _generatorUtils.findExistingTargetsInProject)(targets, userProvidedTargetName);
        projectAlreadyHasViteTargets = alreadyHasNxViteTargets;
        /**
     * This means that we only found unsupported build targets in that project.
     * The only way that buildTarget is defined, means that it is supported.
     *
     * If the `unsupported` flag was false, it would mean that we did not find
     * a build target at all, so we can create a new one.
     *
     * So we only throw if we found a target, but it is unsupported.
     */ if (!validFoundTargetName.build && projectContainsUnsupportedExecutor) {
            throw new Error(`The project ${schema.project} cannot be converted to use the @nrwl/vite executors.`);
        }
        if (alreadyHasNxViteTargets.build && (alreadyHasNxViteTargets.serve || projectType === 'library') && alreadyHasNxViteTargets.test) {
            throw new Error(`The project ${schema.project} is already configured to use the @nrwl/vite executors.
        Please try a different project, or remove the existing targets 
        and re-run this generator to reset the existing Vite Configuration.
        `);
        }
        /**
     * This means that we did not find any supported executors
     * so we don't have any valid target names.
     *
     * However, the executors that we may have found are not in the
     * list of the specifically unsupported executors either.
     *
     * So, we should warn the user about it.
     */ if (!projectContainsUnsupportedExecutor && !validFoundTargetName.build && !validFoundTargetName.serve && !validFoundTargetName.test) {
            await (0, _generatorUtils.handleUnknownExecutors)(schema.project);
        }
        /**
     * There is a possibility at this stage that the user has provided
     * targets with unsupported executors.
     * We keep track here of which of the targets that the user provided
     * are unsupported.
     * We do this with the `userProvidedTargetIsUnsupported` object,
     * which contains flags for each target (whether it is supported or not).
     *
     * We also keep track of the targets that we found in the project,
     * through the findExistingTargetsInProject function, which returns
     * targets for build/serve/test that use supported executors, and
     * can be converted to use the vite executors. These are the
     * kept in the validFoundTargetName object.
     */ await (0, _generatorUtils.handleUnsupportedUserProvidedTargets)(userProvidedTargetIsUnsupported, userProvidedTargetName, validFoundTargetName);
        var _build;
        /**
     * Once the user is at this stage, then they can go ahead and convert.
     */ buildTargetName = (_build = validFoundTargetName.build) != null ? _build : buildTargetName;
        var _serve;
        serveTargetName = (_serve = validFoundTargetName.serve) != null ? _serve : serveTargetName;
        if (projectType === 'application') {
            (0, _generatorUtils.moveAndEditIndexHtml)(tree, schema, buildTargetName);
        }
        (0, _generatorUtils.deleteWebpackConfig)(tree, root, (ref = targets[buildTargetName]) == null ? void 0 : (ref1 = ref.options) == null ? void 0 : ref1.webpackConfig);
        (0, _generatorUtils.editTsConfig)(tree, schema);
    }
    const initTask = await (0, _init.default)(tree, {
        uiFramework: schema.uiFramework,
        includeLib: schema.includeLib
    });
    tasks.push(initTask);
    if (!projectAlreadyHasViteTargets.build) {
        (0, _generatorUtils.addOrChangeBuildTarget)(tree, schema, buildTargetName);
    }
    if (!schema.includeLib) {
        if (!projectAlreadyHasViteTargets.serve) {
            (0, _generatorUtils.addOrChangeServeTarget)(tree, schema, serveTargetName);
        }
        if (!projectAlreadyHasViteTargets.preview) {
            (0, _generatorUtils.addPreviewTarget)(tree, schema, serveTargetName);
        }
    }
    (0, _generatorUtils.createOrEditViteConfig)(tree, schema, false, projectAlreadyHasViteTargets);
    if (schema.includeVitest) {
        const vitestTask = await (0, _vitestGenerator.default)(tree, {
            project: schema.project,
            uiFramework: schema.uiFramework,
            inSourceTests: schema.inSourceTests,
            coverageProvider: 'c8',
            skipViteConfig: true,
            testTarget: testTargetName
        });
        tasks.push(vitestTask);
    }
    await (0, _devkit.formatFiles)(tree);
    return (0, _runTasksInSerial.runTasksInSerial)(...tasks);
}
const _default = viteConfigurationGenerator;
const configurationSchematic = (0, _devkit.convertNxGenerator)(viteConfigurationGenerator);

//# sourceMappingURL=configuration.js.map