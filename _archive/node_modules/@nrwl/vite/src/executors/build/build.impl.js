"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    viteBuildExecutor: ()=>viteBuildExecutor,
    default: ()=>_default
});
const _extends = require("@swc/helpers/lib/_extends.js").default;
require("dotenv/config");
const _vite = require("vite");
const _optionsUtils = require("../../utils/options-utils");
const _js = require("@nrwl/js");
const _fs = require("fs");
const _path = require("path");
const _asyncIterable = require("@nrwl/devkit/src/utils/async-iterable");
async function* viteBuildExecutor(options, context) {
    const normalizedOptions = normalizeOptions(options);
    const projectRoot = context.projectsConfigurations.projects[context.projectName].root;
    const buildConfig = (0, _vite.mergeConfig)((0, _optionsUtils.getViteSharedConfig)(normalizedOptions, false, context), {
        build: (0, _optionsUtils.getViteBuildOptions)(normalizedOptions, context)
    });
    const watcherOrOutput = await runInstance(buildConfig);
    const libraryPackageJson = (0, _path.resolve)(projectRoot, 'package.json');
    const rootPackageJson = (0, _path.resolve)(context.root, 'package.json');
    // For buildable libs, copy package.json if it exists.
    if ((0, _fs.existsSync)(libraryPackageJson) && rootPackageJson !== libraryPackageJson) {
        await (0, _js.copyAssets)({
            outputPath: normalizedOptions.outputPath,
            assets: [
                {
                    input: projectRoot,
                    output: '.',
                    glob: 'package.json'
                }
            ]
        }, context);
    }
    if ('on' in watcherOrOutput) {
        const iterable = (0, _asyncIterable.createAsyncIterable)(({ next  })=>{
            let success = true;
            watcherOrOutput.on('event', (event)=>{
                if (event.code === 'START') {
                    success = true;
                } else if (event.code === 'ERROR') {
                    success = false;
                } else if (event.code === 'END') {
                    next({
                        success
                    });
                }
                // result must be closed when present.
                // see https://rollupjs.org/guide/en/#rollupwatch
                if ('result' in event) {
                    event.result.close();
                }
            });
        });
        yield* iterable;
    } else {
        yield {
            success: true
        };
    }
}
function runInstance(options) {
    return (0, _vite.build)(_extends({}, options));
}
function normalizeOptions(options) {
    const normalizedOptions = _extends({}, options);
    // coerce watch to null or {} to match with Vite's watch config
    if (options.watch === false) {
        normalizedOptions.watch = null;
    } else if (options.watch === true) {
        normalizedOptions.watch = {};
    }
    return normalizedOptions;
}
const _default = viteBuildExecutor;

//# sourceMappingURL=build.impl.js.map